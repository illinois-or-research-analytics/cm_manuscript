\documentclass[12pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{textcomp}
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
\usepackage{caption}
\usepackage{subcaption}								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{color}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{url}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage{natbib}
\usepackage{xcolor}
\usepackage{algpseudocode}
\usepackage{algorithm}


% removed hyperref because of arXiv complaining
\usepackage{authblk}
\usepackage{float}
\usepackage{rotating}
\usepackage{adjustbox}
\usepackage[font=small,labelfont=bf]{caption}
%\usepackage{changes}
\usepackage{changes}
\definechangesauthor[name={George Chacko}, color=blue]{gc}

\usepackage{authblk}
\title{Supplementary Material For ``Finding Well-Connected Communities in Real-World Networks''}
\author[1]{Minhyuk Park\thanks{author order to be determined later}}
\author[1]{Yasamin Tabatabaee\thanks{author order to be determined later}}
\author[1]{Baqiao Liu\thanks{author order to be determined later}}
\author[1]{Placeholder1\thanks{author order to be determined later}}
\author[1]{Placeholder2\thanks{author order to be determined later}}
\author[1]{Placeholder3\thanks{author order to be determined later}}
\author[2]{Dmitriy Korobskiy}
\author[1,3]{George Chacko\thanks{chackoge@illinois.edu}}
\author[1]{Tandy Warnow\thanks{warnow@illinois.edu}}
\affil[1]{Department of Computer Science, University of Illinois Urbana-Champaign, Urbana, IL 61801}
\affil[2]{NTT DATA, McLean, VA 22102}
\affil[3]{Office of Research, Grainger College of Engineering, University of Illinois Urbana-Champaign, Urbana, IL 61801}


\begin{document}
\maketitle



\section{CM Pipeline} 

The input network $N$ is processed in a pipeline that has the following stages:
\begin{itemize}
\item Clustering $N$, using either the Leiden algorithm or Iterative K-core Clustering (IKC)
\item Removing clusters of size $<$ 10 as well as trees (defined as connected clusters where the number $m$ of edges is one less than the number  $n$ of vertices). Depending on the user and the dataset being analyzed, one of the following
options was used to perform this step:
\begin{enumerate}
\item belinda \citep{belinda2022} expressions, e.g., $g1.filter(pl.col('n') > 10)$ and \\ $g1.filter(pl.col('n') != pl.col('m') + 1)$
\item find\_trees.py: a slow script that relies on Networkit \citep{Staudt2016}
\item cluster\_analyzer.py: a parallelized version of find\_trees.py
\item subset\_graph\_nonnetworkit.R: a fast script without dependence on Networkit that also returns maxDegree for a cluster. 
\end{enumerate}

\item Applying connectivity modifier 
\item Removing clusters of size at most 10  (note: there will not be any trees left at this point)
\end{itemize} 



\section{Pseudocode for the Connectivity Modifier}
The input to the Connectivity Modifier (CM) is a network and a  clustering; the output will be a set of well-connected clusters (WCC), obtained
by processing each cluster in the input. 
Thus, each cluster in the output WCC will be a subset of one of the input clusters.
Here we describe CM, beginning  with the necessary definitions.

\begin{itemize}
    \item $\delta(G)$: the minimum degree of  any node in cluster $G$
    \item $deg(u)$: the degree of node $u$
    \item $t(G)$: minimum required edge cut size for  $G$
    \item $\lambda(G)$: the minimum edge cut size of $G$
    \item $mod(G, H)$: modularity of subgraph $H$ w.r.t.~$G$
    \item $f$: clustering method: a clustering method takes as input a graph, and outputs non-singleton subgraphs of the input graph.  
\end{itemize}

Recall that  $t(G)$ is the {\em smallest} a cut can be and still be considered ``large enough".
Furthermore, in our experiments, we set $t(G) = \lfloor \log_{10}(n) \rfloor +1$.  This means that any cut that is below $t(G)$ in number of vertices
will be considered small, and so will be cut.
Here we explore the effect of this definition of $t(G)$, where $G$ is a cluster with $n$ vertices.
\begin{itemize}
\item 
$1 \leq n \leq 9$. 
For all values of $n$ in this range, we obtain $t(G) = \lfloor log_{10}(n) \rfloor +1$, and so $t(G) = 1$.  Hence, for $1 \leq n \leq 9$, we  only require that the
cluster be connected.
\item 
$10 \leq n \leq 99$. For all values of $n$ in this range, we have 
 $t(G) = 2$, which means that if $G$ is a cluster of size $n$ and it has a cut of size $1$, that  cut will
be considered ``too small", and will be cut.  Effectively this only ensures that clusters of size between $10$ and $99$ do not have cut edges.
If a cut edge is found, it will mean that in the CM code, that cut edge will be deleted, thus separating the cluster into two pieces.
In contrast, a cut of size $2$ will be considered large enough, and will not be cut.
\item 
$100 \leq n \leq 999$.
For all values of $n$ in this range, we have $t(G)=3$, which means that if $G$ has a cut of size  at most $2$ it will be considered
too small, and any such cut will be deleted from $G$.
In contrast, a cut of size $3$  or larger will be considered large enough, and will not be cut.
\item 
$1000 \leq n \leq 9999$.
For all values of $n$ in this range, we have $t(G)=4$, which means that if $G$ has a cut of size $3$ or smaller it will be considered
too small, and any such cut will be deleted from $G$.
In contrast, a cut of size $4$ or larger will be considered large enough, and will not be cut.
\end{itemize}

\begin{algorithm}[h]
\caption{The pseudocode for min-cut validity pipeline.}
\begin{algorithmic}[2]
\State $f$: Clustering method (e.g., IKC, Leiden, etc.)
\Function{$g$}{G}
\State WCC $\gets []$ \Comment{This is an empty array}

\State clusters $\gets f(G)$ \Comment{This is an array of clusters generated by $f$}
\State stack $\gets$ clusters  
\While{!stack.empty()} \Comment{While there is a cluster in the stack}
    \State $H$ = stack.pop()
    \While{$\delta(H) < t(H)$} 
    \State delete an arbitrary node $u$ from $H$ where $deg(u) = \delta(H)$ 
    \EndWhile
    \If{$\lambda(H) < t(H)$} \Comment{If the edge cut for H is smaller than $t$}
        \State $H_a, H_b$ $\gets$ $H$ separated by a minimum cut   
        \State stack.extend($f(H_a)$) \Comment{Recluster $H_a$ and $H_b$}
        \State stack.extend($f(H_b)$)  \Comment{and add clusters to stack}
    \Else 
       % \If{$f$ is not modified IKC $\lor$ $mod(G, H) \ge 0$}
            \State WCC $\gets$ WCC $+$ [$H$] \Comment{Add H to WCC}
        \EndIf
\EndWhile
%\If{$f = $ IKC} 
%    \State remove all clusters from ans that have modularity $\leq 0$
%    \EndIf
%\textcolor{blue}{}
\State \Return WCC \Comment{WCC contains only well-connected clusters}
\EndFunction
\end{algorithmic}

\label{alg:full-pipeline}
\end{algorithm}

\clearpage
Note: When 
$f$ (the clustering method) is IKC, then we have made a small modification to the
code for the sake of efficiency in the code.  
Specifically, IKC requires that all the clusters have positive modularity.
 In our CM code, the recursive
calls to the clustering method (IKC) in lines 13 and 14 do not check for positive modularity; instead, this check is delayed until the stack is empty (i.e., after line 18).
At this point, it is possible that some of the clusters in WCC will not have positive modularity.
Therefore, when we run CM with IKC for the clustering method $f$,  we add a processing step after line 18 that checks each cluster in WCC for positive modularity,
and deletes any cluster that fails this test. 
Only after pruning all such clusters from WCC will we return what is left. 
\bibliographystyle{apalike}
\bibliography{cmv1}
\end{document}  